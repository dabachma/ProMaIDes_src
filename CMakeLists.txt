cmake_minimum_required(VERSION 3.16)
#CMake Minimum Limited by target_precompile_headers

# - These variables can be changed based on preference
# - executable_name_after_build is the name of the generated executable file. On windows that would be the xxxx.exe file
# - solution_name is the name of the solution that will be generated by CMake. In Visual Studio that would be the name shown at the top in the project explorer.
# -         As well as the name of the .sln file
set(executable_name_after_build "ProMaIDeS_vc")
set(solution_name "pro_Solution")

# - CMAKE_CONFIGURATION_TYPES allows for multi-configuration generation of projects
# - This allows having different build setting based on configurations
set(CMAKE_CONFIGURATION_TYPES Debug;Release)

# - This is the solution that will be generated
# - solution_name is the name of the solution. In Visual Studio that would be the name shown at the top in the project explorer
project(${solution_name})

# - set_property is used to set a property value
# - USE_FOLDERS is set to ON to allow targets to be added to folders in the project explorer
# - This is purely aesthetic and is used to move the ALL_BUILD and ZERO_CHECK to the CMakePredefinedTargets
set_property(GLOBAL PROPERTY USE_FOLDERS ON)

# - Set the C++ standard to use for the project to C++11 
# - Require the C++ standard to be used
# - If the build is done on Linux (compiled with GNU or Clang) then fpermissive is set to on
# - The -fpermissive downgrades some errors to warnings, some database code used in ProMaIDeS has some nonconforming code
# - MSVC by default is treating these errors as warning, and thus is only affects Linux builds
# - TODO: Fix the nonconforming code that is requiring the fpermissive and then remove -fpermissive
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED on)
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    set(CMAKE_CXX_FLAGS "-fpermissive")
endif()

# - To be able to use the a package, CMake needs to know information about it
# - A package provides this information in .cmake files that find_package reads and interprets
# - find_package needs to know where these .cmake files are so that it can access this information
# - One way (not recommended) to allow find_package to find these files is using CMAKE_PREFIX_PATH
# - Skip the following for the better way
# - The QT directory is added to CMAKE_PREFIX_PATH which is where CMake looks for packages
# - To give Qt access uncomment and change one of the lines below based on your QT installation directory
#set(QT_DIR "C:/Qt/5.15.2/msvc2019_64/")
#set(QT_DIR "/home/ubunntu/Qt/5.15.2/gcc_64/")
#set(CMAKE_PREFIX_PATH "/home/ubunntu/Qt/5.15.2/gcc_64/" ) # Uncomment one of the above and change it according to your system

# - Second way (recommended) to allow find_package to find the files is to add the qt directory to the environment
# - To do this open cmd
# - copy this command (change the path based on your system): setx Qt5_DIR C:\Qt\5.15.2\msvc2019_64 
# - Press enter to add the Qt5_Dir as a user variable
# - Run CMake Again

if (WIN32)
    message("Windows System Detected")
    set(QWT_INCLUDE_DIR     "${PROJECT_SOURCE_DIR}/source_code/Vendors/Qwt/src/")
    set(QWT_LIBRARY_RELEASE "${PROJECT_SOURCE_DIR}/source_code/Vendors/Qwt/lib/qwt.lib")
    set(QWT_LIBRARY_DEBUG   "${PROJECT_SOURCE_DIR}/source_code/Vendors/Qwt/lib/qwtd.lib")
    set(STATIC_LIBS_DIR     "${PROJECT_SOURCE_DIR}/source_code/Vendors/StaticLibs/Winx64/")
endif (WIN32)

if (UNIX AND NOT APPLE)
    message("Linux System Detected")
    set(QWT_INCLUDE_DIR     "${PROJECT_SOURCE_DIR}/source_code/Vendors/Qwt/src/")
    set(QWT_LIBRARY_RELEASE "${PROJECT_SOURCE_DIR}/source_code/Vendors/StaticLibs/Linux/libqwt.so")
    set(QWT_LIBRARY_DEBUG   "${PROJECT_SOURCE_DIR}/source_code/Vendors/StaticLibs/Linux/libqwt.so")
    set(STATIC_LIBS_DIR     "${PROJECT_SOURCE_DIR}/source_code/Vendors/StaticLibs/Linux/")
endif (UNIX AND NOT APPLE)

## Output variables from python
message("QT_DIR set to: " ${QT_DIR})
message("QWT_INCLUDE_DIR set to: " ${QWT_INCLUDE_DIR})
message("QWT_LIBRARY_RELEASE set to: " ${QWT_LIBRARY_RELEASE})
message("QWT_LIBRARY_DEBUG set to: " ${QWT_LIBRARY_DEBUG})
message("STATIC_LIBS_DIR set to: " ${STATIC_LIBS_DIR})
message("")

###########################################################################
## List of files to work with
###########################################################################
# - Set allows giving a value to a variable similar to: UI_FILES = "file1.ui file2.ui file3.ui"
# - A list of .ui Files is made to make it easier to work with them
# - Glob can also be used but this manual way is safer and also the recommended approach for faster in between builds
# - The UI files need to be wrapped to generate the ui-xxxx.h files this is done using qt_wrap_ui
set(UI_FILES
    source_code/Main_Wid.ui
    source_code/Sys_Data_Tree_Wid.ui
)

# - Set allows giving a value to a variable similar to: H_FILES = "file1.h file2.h file3.h"
# - A list of .h Files is made to make it easier to work with them
# - All the h files in this library need to be added here MANUALLY.
# - This variable is passed to the library when creating it so that it knows what files are parts of it
set(H_FILES
    source_code/Main_Wid.h
    source_code/Main_Headers_Precompiled.h
    source_code/Sys_Data_Tree_Wid.h
    source_code/Sys_Output_Text_Wid.h
    source_code/Sys_Dock_Widget.h
    source_code/Sys_Version_Update.h
)

# - Set allows giving a value to a variable similar to: CPP_FILES = "file1.cpp file2.cpp file3.cpp"
# - A list of h Files is made to make it easier to work with them
# - All the .cpp files in this library need to be added here MANUALLY.
# - This variable is passed to the library when creating it so that it knows what files to compile
set(CPP_FILES
    source_code/Main_Wid.cpp
    source_code/Sys_Data_Tree_Wid.cpp
    source_code/Sys_Output_Text_Wid.cpp
    source_code/Sys_Dock_Widget.cpp
    source_code/Sys_Version_Update.cpp
    source_code/main.cpp
)

set(QRC_FILES
    ${CMAKE_SOURCE_DIR}/source_code/system_sys/source_code/gui/resources/system_sys_resource.qrc
    ${CMAKE_SOURCE_DIR}/source_code/system_sys/source_code/gui/resources/hydroxygen.qrc
)

set(RCFiles
    promaides.rc
    source_code/system_hydraulic/source_code/solvergpu/CLCode.rc ##Can't add in a shared library, so it needs to be added here
)

# - Set allows giving a value to a variable similar to: PrecompiledHeaders = "PrecompiledHeaders.h"
# - Set is used here for consistency of the code
# - The precompiledHeader will be targeted by the library so that it precompiles this header file for faster build times
set(PrecompiledHeaders
    source_code/Main_Headers_Precompiled.h
)


##
## Turn on automatic processing of files by QT
##
set(CMAKE_AUTOMOC ON) # To invoke moc (for .cpp files)
set(CMAKE_AUTORCC ON) # To invoke rcc code generator (for resource files)
set(CMAKE_AUTOUIC ON) # To invoke uic (for .ui files)

#Add QWT_DLL definition to entire solution
add_definitions(-DQWT_DLL)

# - find_package tries to find the specified package using Find<package>.cmake files
# - Package such as Qt have CMake files in them that helps the programmer when using the package in his program
# - It is used to define Qt commands symbols such Qt::Core which will be used to link the system_sys to Qt
# - find_package can't find where Qt is installed on your system. The user needs to do this first
# - type the following in cmd to tell CMake where Qt is on your system:
# - setx Qt5_DIR C:\Qt\5.15.2\msvc2019_64 
find_package(Qt5 COMPONENTS Core Sql Svg PrintSupport Widgets Gui Xml REQUIRED)

# - An additional required package for Linux is the X11Extras. Required for the GUI on Linux
if (UNIX AND NOT APPLE)
    find_package(Qt5 COMPONENTS REQUIRED X11Extras)
endif()

# - add_executable create the executable
# - The add_executable is the engine here and is defined as add_executable(<name> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1] [source2 ...])
# - ProMaIDeS is the name given to the target
# - WIN32 is used to selected Windows Subsystem in the linker settings, this is make the application a full GUI application without a console attached
# - What follows are the source codes
add_executable(ProMaIDeS WIN32
    ${UI_FILES}
    ${H_FILES}
    ${CPP_FILES}
    ${QRC_FILES}
    ${RCFiles}
    ${PrecompiledHeaders}
)

# - set_target_properties: Used to set the name of the executable after it has been built. This is the xxxx.exe in windows
# - set_property:   Used to set ProMaIDeS as the startup project.
# -                 The startup project is the project that runs when you press the green start arrow in Visual Studio
# -                 By default ALL_BUILD is the startup project. This command changes it to the ProMaIDeS project
set_target_properties(ProMaIDeS PROPERTIES OUTPUT_NAME ${executable_name_after_build})
set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT ProMaIDeS)

if (CMAKE_BUILD_TYPE MATCHES Debug)
    message("Debug build configuration detected")
    add_definitions(-DQT_DEBUG)
    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
else()
    message("Non-debug build configuration detected")
endif()

# - target_precompile_headers sets the precompiled headers of the target (library)
# - system_hydraulic is the target
# - The precompiled headers is set to PRIVATE as no other library needs access to it
target_precompile_headers(ProMaIDeS PRIVATE ${PrecompiledHeaders})

# - add_subdirectory tells CMake where to find other libraries (other CMakeLists.txt)
# - Build order is not important as each CMakeLists.txt knows what library it needs
add_subdirectory(source_code/system_alt/)
add_subdirectory(source_code/system_cost/)
add_subdirectory(source_code/system_dam/)
add_subdirectory(source_code/system_fpl/)
add_subdirectory(source_code/system_hydraulic/)
add_subdirectory(source_code/system_hydraulic/source_code/solver/)
add_subdirectory(source_code/system_hydraulic/source_code/solvergpu/)
add_subdirectory(source_code/system_madm/)
add_subdirectory(source_code/system_risk/)
add_subdirectory(source_code/system_sys/)

# - target_include_directories sets the include directories for a specific target
# - In this case the include directories for the system_hydraulic package are defined
# - It is set to PUBLIC meaning the parent targets also inherit these directories
# - For example: the HYD Library is a parent of solvergpu and has access to things like: include "GodunovScheme.h"
# - The directories of children libraries (solver & solvergpu) are inherited. They don't need to be specified here
# - The inheritance is declared in target_link_libraries
# - ${CMAKE_CURRENT_BINARY_DIR} because it is the location of the ui_xxxx.h files that are generated by qt_wrap_ui
target_include_directories(ProMaIDeS
    PUBLIC
        ${CMAKE_CURRENT_BINARY_DIR}
        source_code
        source_code/gui
)

# - target_link_libraries links libraries to a specific target
# - In this case linking the HYD Library to the solvergpu library
# - The target_include_directories tells the program where the headers are. But not what the classes do
# - The dlls or libs are what include the functions themselves.
# - All children libraries are declared here
# - Even though Qt Class are also required, they don't need to be specified here as they are inherited automatically frpm system_sys
target_link_libraries(ProMaIDeS
    system_alt
    system_cost
    system_dam
    system_fpl
    system_hydraulic
    solver
    solvergpu
    system_madm
    system_risk
    system_sys
)

# - target_link_options adds options to the linker
# - We want to delay loading the OpenCL.dll on runtime
# - This allows users who don't have an OpenCL runtime to still use the program in CPU mode
# - The programmer is required to check if OpenCL.dll exists, and to only use OpenCL functions if it exists
# TODO: Alaa Not sure what the Linux equivalent is?
if(MSVC)
  target_link_options(ProMaIDeS PRIVATE "/DELAYLOAD:OpenCL.dll")
endif()

# - qt_wrap_ui (or qt5_wrap_ui) wraps ui files, in other words generating .h files from them
# - AUTOMOC can also be used which does this automatically. This, however, is not recommended, it brings more troubles than solutions  
qt_wrap_ui(UI_FILES ${UI_FILES})


######## POST BUILD STUFF ########


if (UNIX AND NOT APPLE)
add_custom_command(TARGET ProMaIDeS POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
    ${CMAKE_CURRENT_SOURCE_DIR}/source_code/system_hydraulic/source_code/solvergpu/source_code/opencl
    $<TARGET_FILE_DIR:ProMaIDeS>/opencl
)
endif (UNIX AND NOT APPLE)


## Copying dlls
if (WIN32)
add_custom_command(TARGET ProMaIDeS POST_BUILD
    COMMAND ${CMAKE_COMMAND} -E copy_directory
        "${STATIC_LIBS_DIR}$<CONFIGURATION>"
        $<TARGET_FILE_DIR:ProMaIDeS>)
endif (WIN32)

# App Image should do its own copying